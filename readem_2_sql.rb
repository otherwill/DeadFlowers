# doing it object style
require 'rubygems'
require 'sqlite3'

#!!! have to add in set info!

# where we are putting this stuff
# make it new each time
DBNAME = "deadflowers.sqlite"
File.delete(DBNAME) if File.exists?DBNAME
DB = SQLite3::Database.new( DBNAME )

##### MOVED TO GIT FOR VERSION CONTROL RECONFIGURED FOLDERS SO PATHS FILES IN HERE NEED TO BE UPDATED!

# have to figure out the linking - indices and id's ..
DB.execute("CREATE TABLE shows(
  show_id INTEGER PRIMARY KEY,
  date_str,
  venue,
  city
  )")
DB.execute("CREATE TABLE songs(
  song_id INTEGER PRIMARY KEY,
  song_called CONSTRAINT dedup_song UNIQUE ON CONFLICT IGNORE
  )")
# Note 'set' is a keyword in sql.  Could qoute it but this always means trouble.
# so using 'track'.  Pretend its a record album... Note just counts so 3 = Encore, etc.
# also note stripped out sound checks so track 1 = first set. Still a further note
# this is not very robust as it depends on having no exteraneous blank lines in
# the input file ...
DB.execute("CREATE TABLE performances (
  show_id,
  song_id,
  track
  )")

# so old school, define files & initialize ...
#name_listin = "./edit_65_95_v1.txt"
# 27 Jul moved this file to workingDBS songs_n_shows.txt (when moved to git for version control)
# naming them here prevents them from being local to block
linenum = 0
blanklines = 0
track = 0
show_id = 0
song_id = 0

filed_away = {}   # hash to track songs we've seen

# used to put a row into the shows TABLE
# if we were good we would convert the date string to ISO format
# Note I think the way we defined the keys, they will be autogenerated
# and are alises of sorts for row id.
show_insert_query = "INSERT INTO shows(date_str, venue, city) VALUES(?, ?, ?)"

# more inserts, songs are simple, performances are basically two id's
song_insert_query = "INSERT INTO songs(song_called) VALUES(?)"
perf_insert_query = "INSERT INTO performances( show_id, song_id, track) VALUES( ?, ?,?)"

# open source file
listin = File.new(name_listin,"r")

listin.each_line { |line|
  linenum += 1

  # classify line & write data
  # unlike object oriented version, not building object but
  # simply transcribing into SQL.
  # If we made objects, that would enable a 'browser' in rails!

  case line

  when /^\s*$/ #blank line
    # can check this count against grep results
    blanklines += 1
    # this gets reset on show line
    track += 1

  when /^\d/ #if we see a number first on the line, a date +> a show header
    # crude progress bar
    puts " "
    print "*"
    $stdout.flush

    #reset track aka set
    track = 0

    #split into fields.  gotta love regexp and PITA data files.
    # Dates can have dashes or slashes so make - to / first
    # splitting on whitespace followed by a word boundry character
    # Venues can have parens.  Cities can have periods ("St.")  What about canada?
    line = line.gsub(/(\d)-(\d)/,'\1/\2')
    result = /(\d{1,2}[\/]\d{1,2}[\/]\d{1,2})\s*(\w[ \-'.\(\)\w]*),\s*(\w[ .,\w]*)/.match(line)
    if result
      # puts "got #{result[1]} | #{result[2]} | #{result[3]}"
      insert_result = DB.execute(show_insert_query, result[1], result[2],result[3] )
      # i could check for errors puts DB.errcode.to_s
      show_id = DB.last_insert_row_id.to_s

    else #these go to stderr so can redirect to file for dignostics using 2>
      $stderr.puts "regex fail in show at #{linenum}:"
      $stderr.puts line
    end

  when /^[a-zA-Z]/

    print "."
    $stdout.flush

    song = line.strip
    # have we seen this? Check our filed_away hash ...
    if filed_away[song].nil?
      #haven't seen it, insert and grab record id
      DB.execute(song_insert_query, line.strip )
      song_id = DB.last_insert_row_id
      filed_away[song] = song_id
    else
      # we have seen it, so get id from hash
      song_id = filed_away[song]
    end
    #now, add an entry to the show x song table ...
    DB.execute(perf_insert_query, show_id, song_id, track )

  end # case stmt

} #end line iterator block

listin.close
DB.close

puts ""
puts "Well, that is that, #{blanklines} blank lines found"
